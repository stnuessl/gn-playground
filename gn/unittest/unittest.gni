#
# The MIT License (MIT)
#
# Copyright (c) 2025 Steffen Nuessle
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

import("//gn/clang-tidy/clang-tidy.gni")
import("//gn/echo/echo.gni")
import("//gn/python/python.gni")

declare_args() {
  unittest_launcher = ""
  unittest_launcher_args = []
}

_prefix = "unittest"

template("unittest") {
  assert(!defined(invoker.check_includes),
         "'check_includes' must be unspecified")
  assert(!defined(invoker.cflags), "'cflags' must be unspecified")
  assert(!defined(invoker.cflags_c), "'cflags_c' must be unspecified")
  assert(!defined(invoker.cflags_cc), "'cflags_cc' must be unspecified")
  assert(!defined(invoker.defines), "'defines' must be unspecified")
  assert(!defined(invoker.libs), "'libs' must be unspecified")
  assert(!defined(invoker.testonly), "'testonly' must be unspecified")
  assert(defined(invoker.source), "'source' must be defined")

  executable_target_name = "$_prefix-$target_name"
  testonly = true

  executable(executable_target_name) {
    check_includes = false

    _ignore = [
      "source",
      "sources",
      "testonly",
      "tests",
      "line_coverage",
      "branch_coverage",
    ]

    forward_variables_from(invoker, "*", _ignore)

    sources = [ invoker.source ] + invoker.tests

    defines = [ "UNITTEST" ]
    cflags = [
      "-pedantic",
      "-Wall",
      "-Wextra",
      "-Werror",
      "-fno-omit-frame-pointer",
      "-Og",
      "-g2",
    ]

    cflags_c = [
      "-std=c11",
      "-fprofile-arcs",
      "-ftest-coverage",
    ]
    cflags_cc = [ "-std=c++17" ]
    libs = [
      "gtest",
      "gcov",
    ]
    ldflags = [ "-coverage" ]

    metadata = {
      template = [ "unittest" ]
      validates = [ rebase_path(invoker.source, root_build_dir) ]
    }
  }

  clang_tidy(executable_target_name) {
    sources = invoker.tests
  }

  execute_target_name = "$_prefix-execute-$target_name"
  action(execute_target_name) {
    inputs = [ "$target_out_dir/$executable_target_name" ]
    deps = [ ":$executable_target_name" ]
    mnemonic = "RUN"

    outputs = [ "$target_gen_dir/$target_name-output.json" ]

    if (unittest_launcher != "") {
      script = unittest_launcher

      args = unittest_launcher_args + [ rebase_path(inputs[0], root_build_dir) ]
    } else {
      script = inputs[0]
      args = []
    }

    args += [
      "--gtest_shuffle",
      "--gtest_output=json:" + rebase_path(outputs[0], root_build_dir),
    ]
  }

  coverage_target_name = "$_prefix-coverage-$target_name"
  python(coverage_target_name) {
    testonly = true
    deps = [ ":$execute_target_name" ]
    inputs = get_target_outputs(deps[0])
    outputs = [ "$target_gen_dir/$coverage_target_name.html" ]
    mnemonic = "COVERAGE"
    requirements = [ "gcovr" ]

    if (defined(invoker.line_coverage)) {
      line_coverage = invoker.line_coverage
    } else {
      line_coverage = "100"
    }

    if (defined(invoker.branch_coverage)) {
      branch_coverage = invoker.branch_coverage
    } else {
      branch_coverage = "100"
    }

    object_out_dir = get_path_info(invoker.source, "out_dir")

    module = "gcovr"
    args = [
      "--gcov-executable",
      "llvm-cov gcov",
      "--root",
      rebase_path("//.", root_build_dir),
      "-j",
      "1",
      "--filter",
      string_replace(rebase_path(invoker.source, root_build_dir), ".", "\."),
      "--fail-under-line",
      line_coverage,
      "--fail-under-branch",
      branch_coverage,
      "--html",
      rebase_path(outputs[0], root_build_dir),
      "--html-details",
      "--html-title",
      "GCC Code Coverage Report - " + get_path_info(invoker.source, "file"),
      "--delete",
      rebase_path(object_out_dir, root_build_dir),
    ]
  }

  echo_target_name = "$_prefix-info-$target_name"
  echo(echo_target_name) {
    deps = [
      ":$coverage_target_name",
      ":$execute_target_name",
    ]
    _coverage_inputs = get_target_outputs(deps[0])
    _execute_inputs = get_target_outputs(deps[1])

    mnemonic = "INFO"
    inputs = _execute_inputs + _coverage_inputs
    args = [
      "Test Report     : " + rebase_path(_execute_inputs[0]),
      "Coverage Report : " + rebase_path(_coverage_inputs[0]),
    ]
  }

  _group_name = "$_prefix-file-$target_name"
  group(_group_name) {
    deps = [ ":${echo_target_name}" ]
  }

  foreach(source, invoker.tests) {
    _file_name = get_path_info(source, "name")
    _group_name = "$_prefix-file-$_file_name"

    group(_group_name) {
      deps = [ ":${echo_target_name}" ]
    }
  }
}

# A convenience template to easily define a group for unit test targets.
template("unittest_group") {
  assert(defined(invoker.deps), "'deps' must be specified")

  group(target_name) {
    _ignore = [ "deps" ]

    forward_variables_from(invoker, "*", _ignore)

    testonly = true
    deps = []
    foreach(_dep, invoker.deps) {
      deps += [ string_replace(_dep, ":", ":$_prefix-file-", 1) ]
    }
  }
}
